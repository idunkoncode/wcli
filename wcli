#!/usr/bin/env python3
# wcli - A multi-distro declarative CLI wrapper tool
#
import os
import sys
import yaml
import subprocess
import argparse
import shutil
from pathlib import Path

# --- Configuration Paths ---
#
SYS_CONFIG_DIR = Path(os.environ.get("SYS_CONFIG_DIR", Path.home() / ".config" / "wcli-config"))
CONFIG_FILE = SYS_CONFIG_DIR / "config.yaml"
PACKAGES_DIR = SYS_CONFIG_DIR / "packages"
STATE_DIR = SYS_CONFIG_DIR / "state"
STATE_FILE = STATE_DIR / "installed.yaml"

# --- Colors ---
#
RED = '\033[0;31m'
GREEN = '\033[0;32m'
YELLOW = '\033[1;33m'
BLUE = '\033[0;34m'
NC = '\033[0m'

# --- Distro Provider Loading ---

def get_provider():
    """
    Detects the OS and imports the correct provider module.
    """
    distro_id = ""
    id_like = ""
    try:
        with open("/etc/os-release") as f:
            for line in f:
                if line.startswith("ID="):
                    distro_id = line.strip().split('=')[1].lower().strip('"')
                elif line.startswith("ID_LIKE="):
                    id_like = line.strip().split('=')[1].lower().strip('"')

        # --- FIX: More robust detection ---
        # This logic now checks ID and ID_LIKE explicitly.
        distro_name = ""
        if "fedora" in distro_id:
            from providers.fedora import Provider
            distro_name = "fedora"
        elif "arch" in distro_id:
            from providers.arch import Provider
            distro_name = "arch"
        elif "debian" in distro_id or "ubuntu" in distro_id or "pop" in distro_id or "debian" in id_like or "ubuntu" in id_like:
            from providers.debian import Provider
            distro_name = "debian"
        elif "opensuse" in distro_id:
            from providers.opensuse import Provider
            distro_name = "opensuse"
        elif "gentoo" in distro_id:
            from providers.gentoo import Provider
            distro_name = "gentoo"
        elif "void" in distro_id:
            from providers.void import Provider
            distro_name = "void"
        else:
            raise ImportError(f"No matching provider found for ID={distro_id}, ID_LIKE={id_like}")
        
        print(f"{BLUE}System detected: {distro_id} (using {distro_name} provider){NC}")
        return Provider()

    # --- FIX: Better error message for missing 'providers' ---
    except ImportError as e:
        print(f"{RED}Error: A provider module could not be imported.{NC}")
        print(f"{YELLOW}This almost always means the 'providers' directory is missing from the install location (e.g., /usr/local/lib/wcli/).{NC}")
        print(f"Details: {e}")
        print("Please re-run the install.sh script from the source directory that contains both 'wcli' and the 'providers' folder.")
        sys.exit(1)
    except (FileNotFoundError, UnboundLocalError) as e:
        print(f"{RED}Error: Cannot detect distribution. /etc/os-release not found or is unreadable.{NC}")
        print(f"Details: {e}")
        sys.exit(1)

# --- Core Logic Functions ---

def load_config() -> dict:
    """Loads the main config.yaml file."""
    if not CONFIG_FILE.exists():
        print(f"{RED}Error: Configuration file not found: {CONFIG_FILE}{NC}")
        print("Run 'wcli init' to create one.")
        sys.exit(1)
    try:
        with open(CONFIG_FILE, 'r') as f:
            return yaml.safe_load(f) or {}
    except Exception as e:
        print(f"{RED}Error loading {CONFIG_FILE}: {e}{NC}")
        sys.exit(1)

def write_config(config: dict):
    """Writes to the main config.yaml file."""
    try:
        SYS_CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        with open(CONFIG_FILE, 'w') as f:
            yaml.dump(config, f, sort_keys=False)
    except Exception as e:
        print(f"{RED}Error writing {CONFIG_FILE}: {e}{NC}")
        sys.exit(1)

def get_declared_packages(config: dict) -> dict:
    """
    Parses all YAMLs to get a dictionary of all declared package lists.
    """
    package_lists = {
        "packages": set(),
        "arch_aur": set(),
        "fedora_copr": {},
        "debian_ppa": {},
        "opensuse_obs": {},
        "gentoo_overlay": {},
        "void_src": set(),
    }
    excluded_packages = set()
    hostname = config.get('host', '')

    def load_pkgs_from_file(file_path):
        if file_path.exists():
            try:
                with open(file_path, 'r') as f:
                    data = yaml.safe_load(f)
                    if not data:
                        return
                    
                    # Handle set-like lists
                    for key in ["packages", "arch_aur", "void_src"]:
                        if key in data and data[key]:
                            package_lists[key].update(data[key])
                    
                    # Handle map-like lists
                    for key in ["fedora_copr", "debian_ppa", "opensuse_obs", "gentoo_overlay"]:
                         if key in data and data[key]:
                            for repo, pkgs in data[key].items():
                                if repo not in package_lists[key]:
                                    package_lists[key][repo] = set()
                                package_lists[key][repo].update(pkgs)

                    if "exclude" in data and data["exclude"]:
                        excluded_packages.update(data["exclude"])
                        
            except Exception as e:
                print(f"{YELLOW}Warning: Could not parse {file_path}: {e}{NC}")

    # 1. Load base packages
    load_pkgs_from_file(PACKAGES_DIR / "base.yaml")

    # 2. Load host-specific packages
    host_file = PACKAGES_DIR / "hosts" / f"{hostname}.yaml"
    load_pkgs_from_file(host_file)

    # 3. Load enabled module packages
    if config.get("enabled_modules"):
        for module in config["enabled_modules"]:
            module_file = PACKAGES_DIR / "modules" / f"{module}.yaml"
            load_pkgs_from_file(module_file)

    # 4. Load additional packages from config
    if config.get("additional_packages"):
        package_lists["packages"].update(config["additional_packages"])

    # 5. Apply exclusions
    package_lists["packages"] -= excluded_packages
    
    return package_lists

def run_cmd(cmd: list, cwd: Path = None, check: bool = True) -> subprocess.CompletedProcess:
    """Helper to run a non-interactive command and capture output."""
    return subprocess.run(cmd, cwd=cwd, check=check, text=True, capture_output=True, errors='ignore')

# <-- NEW: Command runner for interactive commands like 'list' or 'restore' -->
def run_interactive_cmd(cmd: list, cwd: Path = None, check: bool = True) -> bool:
    """Helper to run an interactive command that streams output."""
    try:
        # Runs the command and streams STDOUT/STDERR to the user's terminal
        subprocess.run(cmd, cwd=cwd, check=check)
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False
    except KeyboardInterrupt:
        print(f"\n{YELLOW}Command cancelled.{NC}")
        return False

# <-- CHANGE: Renamed to be generic -->
def create_auto_snapshot():
    """Creates a pre-sync snapshot using snapper or timeshift."""
    
    comment = "wcli-sync auto-snapshot"
    
    # --- NEW: Snapper and Timeshift auto-detection ---
    if shutil.which("snapper"):
        print(f"{BLUE}Using snapper to create snapshot...{NC}")
        try:
            # Snapper's 'create' command is designed for this
            run_cmd(["sudo", "snapper", "create", "--type", "pre", "--description", comment, "--cleanup-algorithm", "timeline"])
            print(f"{GREEN}Snapper snapshot created successfully{NC}")
        except (subprocess.CalledProcessError, FileNotFoundError):
            print(f"{YELLOW}Warning: Failed to create snapper snapshot. Continuing anyway...{NC}")
            
    elif shutil.which("timeshift"):
        print(f"{BLUE}Using timeshift to create snapshot...{NC}")
        try:
            run_cmd(["sudo", "timeshift", "--create", "--comments", comment, "--scripted"])
            print(f"{GREEN}Timeshift snapshot created successfully{NC}")
        except (subprocess.CalledProcessError, FileNotFoundError):
            print(f"{YELLOW}Warning: Failed to create timeshift snapshot. Continuing anyway...{NC}")
            
    else:
        print(f"{YELLOW}Warning: No snapshot tool (snapper, timeshift) found. Skipping snapshot.{NC}")

# --- Command Functions ---

def cmd_sync(provider, args):
    """
    Declarative sync command.
    """
    print(f"{BLUE}Loading package configuration...{NC}")
    config = load_config()
    
    all_package_lists = get_declared_packages(config)
    declared_packages = all_package_lists["packages"]
    
    installed_packages = provider.get_installed_packages()

    to_install = list(declared_packages - installed_packages)
    to_remove = []

    if args.prune:
        if STATE_FILE.exists():
            try:
                with open(STATE_FILE, 'r') as f:
                    managed_packages = set(yaml.safe_load(f).get("packages", []))
                
                # Find packages that *we* managed but are no longer declared
                to_remove = list((managed_packages - declared_packages) & installed_packages)
            except Exception as e:
                 print(f"{YELLOW}Warning: Could not read state file {STATE_FILE}. Cannot prune. {e}{NC}")
        else:
            print(f"{YELLOW}Warning: State file not found. Cannot prune.{NC}")
    
    # --- Helper Package Logic ---
    helpers_to_run = {
        "aur": (provider.install_aur, list(all_package_lists["arch_aur"])),
        "copr": (provider.install_copr, all_package_lists["fedora_copr"]),
        "ppa": (provider.install_ppa, all_package_lists["debian_ppa"]),
        "obs": (provider.install_obs, all_package_lists["opensuse_obs"]),
        "overlay": (provider.install_overlay, all_package_lists["gentoo_overlay"]),
        "src": (provider.install_src, list(all_package_lists["void_src"])),
    }
    
    # Display summary
    print(f"\n{BLUE}=== Sync Summary ==={NC}")
    
    print(f"{BLUE}--- Official Repos ---{NC}")
    if to_install:
        print(f"{GREEN}Packages to install ({len(to_install)}):{NC}")
        for pkg in to_install: print(f"  {pkg}")
    else:
        print(f"{GREEN}No official packages to install{NC}")
    
    if to_remove:
        print(f"\n{YELLOW}Packages to remove ({len(to_remove)}):{NC}")
        for pkg in to_remove: print(f"  {pkg}")
    elif args.prune:
        print(f"{GREEN}No official packages to remove{NC}")

    # --- Helper Summary ---
    total_helpers = 0
    for name, (func, packages) in helpers_to_run.items():
        if packages:
            total_helpers += 1
            print(f"\n{BLUE}--- Helper: {name.upper()} ---{NC}")
            print(f"{GREEN}Packages to install ({len(packages)}):{NC}")
            if isinstance(packages, dict):
                for repo, pkgs in packages.items():
                    print(f"  From {repo}: {', '.join(pkgs)}")
            else:
                for pkg in packages: print(f"  {pkg}")

    if not to_install and not to_remove and total_helpers == 0:
        print(f"\n{GREEN}System is already in sync!{NC}")
        return

    if args.dry_run:
        print(f"\n{BLUE}Dry run - no changes made{NC}")
        return

    if not args.force:
        choice = input("\nApply these changes? [y/N] ")
        if not choice.lower().startswith('y'):
            print(f"{YELLOW}Cancelled{NC}")
            return

    # <-- CHANGE: Call the new generic snapshot function -->
    if not args.no_backup:
        create_auto_snapshot()

    # --- Run Installers ---
    
    # 1. Official Packages
    if to_install:
        print(f"\n{BLUE}Installing official packages...{NC}")
        if provider.install(to_install):
            print(f"{GREEN}Packages installed successfully{NC}")
        else:
            print(f"{RED}Error: Failed to install official packages{NC}")
            
    if to_remove:
        print(f"\n{BLUE}Removing packages...{NC}")
        if provider.remove(to_remove):
            print(f"{GREEN}Packages removed successfully{NC}")
        else:
            print(f"{RED}Error: Failed to remove packages{NC}")

    # 2. Helper Packages
    for name, (func, packages) in helpers_to_run.items():
        if packages:
            print(f"\n{BLUE}Installing {name.upper()} packages...{NC}")
            if func(packages): # Call the provider's function
                print(f"{GREEN}{name.upper()} packages installed successfully{NC}")
            else:
                print(f"{RED}Error: Failed to install {name.upper()} packages{NC}")

    # TODO: Post-install hooks
    
    print(f"\n{BLUE}Updating state file...{NC}")
    STATE_DIR.mkdir(parents=True, exist_ok=True)
    try:
        # We only track official packages in the state file for pruning
        with open(STATE_FILE, 'w') as f:
            yaml.dump({"packages": sorted(list(declared_packages))}, f)
    except Exception as e:
        print(f"{RED}Error writing state file {STATE_FILE}: {e}{NC}")
        
    print(f"\n{GREEN}Sync complete!{NC}")

def cmd_module_list(provider, args):
    """
    Lists all available modules and their status.
    """
    config = load_config()
    enabled_modules = set(config.get("enabled_modules", []))
    print(f"{BLUE}=== Available Modules ==={NC}\n")

    try:
        for module_file in (PACKAGES_DIR / "modules").glob("*.yaml"):
            module_name = module_file.stem
            try:
                with open(module_file, 'r') as f:
                    data = yaml.safe_load(f) or {}
            except Exception as e:
                print(f"{YELLOW}Warning: Could not parse {module_file}: {e}{NC}")
                continue
            
            desc = data.get("description", "No description")
            conflicts = ", ".join(data.get("conflicts", []))

            # Get counts for all package types
            pkg_counts = []
            if data.get("packages"):
                pkg_counts.append(f"Packages: {len(data['packages'])}")
            if data.get("arch_aur"):
                pkg_counts.append(f"AUR: {len(data['arch_aur'])}")
            if data.get("fedora_copr"):
                pkg_counts.append(f"COPR: {len(data['fedora_copr'])}")
            if data.get("debian_ppa"):
                pkg_counts.append(f"PPA: {len(data['debian_ppa'])}")
            # (add more for OBS, Gentoo, Void)
            
            if module_name in enabled_modules:
                status = f"{GREEN}enabled{NC}"
            else:
                status = f"{YELLOW}disabled{NC}"
                
            print(f"  {BLUE}{module_name}{NC} [{status}]")
            print(f"    {desc}")
            print(f"    {' | '.join(pkg_counts)}")
            if conflicts:
                print(f"    {RED}Conflicts with: {conflicts}{NC}")
            print("")
    except FileNotFoundError:
        print(f"{YELLOW}No modules directory found at {PACKAGES_DIR / 'modules'}{NC}")

def cmd_module_enable(provider, args):
    """
    Enables a module in config.yaml.
    """
    config = load_config()
    module_name = args.name
    module_file = PACKAGES_DIR / "modules" / f"{module_name}.yaml"

    if not module_file.exists():
        print(f"{RED}Error: Module '{module_name}' not found at {module_file}{NC}")
        sys.exit(1)

    enabled_modules = set(config.get("enabled_modules", []))
    if module_name in enabled_modules:
        print(f"{YELLOW}Module '{module_name}' is already enabled{NC}")
        return

    # Check for conflicts
    try:
        with open(module_file, 'r') as f:
            data = yaml.safe_load(f) or {}
    except Exception as e:
        print(f"{RED}Error reading module {module_file}: {e}{NC}")
        return
    
    conflicts = data.get("conflicts", [])
    if conflicts:
        for conflict in conflicts:
            if conflict in enabled_modules:
                print(f"{RED}Warning: '{module_name}' conflicts with enabled module '{conflict}'{NC}")
                choice = input(f"Disable '{conflict}' and enable '{module_name}'? [y/N] ")
                if choice.lower().startswith('y'):
                    enabled_modules.remove(conflict)
                else:
                    print(f"{YELLOW}Cancelled{NC}")
                    return

    enabled_modules.add(module_name)
    config["enabled_modules"] = sorted(list(enabled_modules))
    write_config(config)
    print(f"{GREEN}Module '{module_name}' enabled{NC}")
    print("Run 'wcli sync' to install packages")

def cmd_module_disable(provider, args):
    """
    Disables a module in config.yaml.
    """
    config = load_config()
    module_name = args.name
    enabled_modules = set(config.get("enabled_modules", []))

    if module_name not in enabled_modules:
        print(f"{YELLOW}Module '{module_name}' is not enabled{NC}")
        return

    enabled_modules.remove(module_name)
    config["enabled_modules"] = sorted(list(enabled_modules))
    write_config(config)
    print(f"{GREEN}Module '{module_name}' disabled{NC}")
    print("Run 'wcli sync --prune' to remove packages")

def cmd_status(provider, args):
    """
    Shows the current configuration and sync status.
    """
    print(f"{BLUE}=== Configuration Status ==={NC}")
    try:
        config = load_config()
    except SystemExit:
        return # Handle case where config doesn't exist yet

    print(f"  Distro: {GREEN}{provider.__class__.__module__.split('.')[-1]}{NC}")
    print(f"  Hostname: {GREEN}{config.get('host', 'Not Set')}{NC}")
    
    enabled_modules = config.get("enabled_modules", [])
    print(f"\n{BLUE}Enabled Modules ({len(enabled_modules)}):{NC}")
    if enabled_modules:
        for module in enabled_modules:
            print(f"  - {module}")
    else:
        print("  (none)")

    # Package summary
    all_package_lists = get_declared_packages(config)
    declared_official = all_package_lists["packages"]
    installed = provider.get_installed_packages()
    to_install = declared_official - installed

    print(f"\n{BLUE}Packages:{NC}")
    print(f"  Declared: {len(declared_official)} (Official)")
    print(f"  To install: {len(to_install)} (Official)")
    
    # Show counts for all helpers that have packages
    for name, pkgs in all_package_lists.items():
        if name != "packages" and pkgs:
             print(f"  Declared: {len(pkgs)} ({name.upper()})")
    
    if to_install or any(pkgs for name, pkgs in all_package_lists.items() if name != "packages"):
        if not to_install and all(not pkgs for name, pkgs in all_package_lists.items() if name != "packages"):
             print(f"\n{GREEN}System is in sync!{NC}")
        else:
             print(f"\n{YELLOW}System is out of sync. Run 'wcli sync' to install.{NC}")
    else:
        print(f"\n{GREEN}System is in sync!{NC}")

def cmd_init(provider, args):
    """
    Initializes the wcli-config directory structure.
    """
    print(f"{BLUE}Initializing wcli-config directory structure...{NC}")
    
    if SYS_CONFIG_DIR.exists() and not args.force:
        print(f"{YELLOW}Warning: {SYS_CONFIG_DIR} already exists.{NC}")
        choice = input("Reinitialize? This will backup existing files. [y/N] ")
        if not choice.lower().startswith('y'):
            print(f"{YELLOW}Cancelled{NC}")
            return
        
        try:
            backup_dir = SYS_CONFIG_DIR.parent / f"wcli-config.backup.{os.times().elapsed}"
            print(f"{BLUE}Backing up existing directory to: {backup_dir}{NC}")
            SYS_CONFIG_DIR.rename(backup_dir)
        except Exception as e:
            print(f"{RED}Error backing up directory: {e}{NC}")
            return

    try:
        # Create directory structure
        (PACKAGES_DIR / "hosts").mkdir(parents=True, exist_ok=True)
        (PACKAGES_DIR / "modules").mkdir(parents=True, exist_ok=True)
        (STATE_DIR).mkdir(parents=True, exist_ok=True)
        (SYS_CONFIG_DIR / "scripts").mkdir(parents=True, exist_ok=True)
        
        hostname = os.uname().nodename
        
        # Create config.yaml
        config_data = {
            "host": hostname,
            "enabled_modules": [],
            "additional_packages": [],
            "auto_prune": False
        }
        write_config(config_data)
        print(f"{GREEN}✓{NC} Created config.yaml with hostname: {hostname}")

        # Create base.yaml (distro-specific)
        base_data = provider.get_base_packages()
        with open(PACKAGES_DIR / "base.yaml", 'w') as f:
            yaml.dump(base_data, f, sort_keys=False)
        print(f"{GREEN}✓{NC} Created packages/base.yaml for {provider.__class__.__module__}")

        # Create host-specific package file
        host_data = {
            "description": f"Packages specific to {hostname}",
            "packages": [],
            "exclude": []
        }
        with open(PACKAGES_DIR / "hosts" / f"{hostname}.yaml", 'w') as f:
            yaml.dump(host_data, f, sort_keys=False)
        print(f"{GREEN}✓{NC} Created packages/hosts/{hostname}.yaml")
        
        # Create .gitignore
        (STATE_DIR / ".gitignore").write_text("# Auto-generated state files\ninstalled.yaml\n")
        print(f"{GREEN}✓{NC} Created state/.gitignore")
        
        # Create example module
        (PACKAGES_DIR / "modules" / "example.yaml").write_text(
            "# Example module template\n\n"
            "description: Example module - customize or delete this\n\n"
            "packages:\n  # - package1\n\n"
            "arch_aur:\n  # - aur_package_1\n\n"
            "fedora_copr:\n  # \"user/repo\":\n  #   - copr_package_1\n\n"
            "debian_ppa:\n  # \"ppa:user/repo\":\n  #   - ppa_package_1\n\n"
            "conflicts: []\n\n"
            "post_install_hook: \"\"\n"
        )
        print(f"{GREEN}✓{NC} Created example module (with helper keys)")
        
        # Create README.md
        (SYS_CONFIG_DIR / "README.md").write_text(
            "# wcli-config\n\n"
            "Declarative package management configuration for Linux.\n\n"
            "## Structure\n\n"
            "- `config.yaml` - Main configuration file\n"
            "- `packages/base.yaml` - Base packages for all machines\n"
            "- `packages/hosts/` - Host-specific package configurations\n"
            "- `packages/modules/` - Optional package modules\n"
            "- `scripts/` - Post-install hook scripts\n"
            "- `state/` - Auto-generated state files (git-ignored)\n\n"
            "## Usage\n\n"
            "Run `wcli help` to see commands.\n"
        )
        print(f"{GREEN}✓{NC} Created README.md")

        print(f"\n{GREEN}Initialization complete!{NC}")
        print("Next steps:\n  1. Edit YAML files in packages/\n  2. Run 'wcli repo init' (recommended)\n  3. Run 'wcli sync'")
    except Exception as e:
        print(f"{RED}Error during initialization: {e}{NC}")

def cmd_repo(provider, args):
    """
    Handles all git repository subcommands.
    """
    if not shutil.which("git"):
        print(f"{RED}Error: 'git' command not found. Please install git.{NC}")
        return
        
    if not SYS_CONFIG_DIR.exists():
        print(f"{RED}Error: Config directory not found. Run 'wcli init' first.{NC}")
        return

    repo_cmd = args.repo_command
    
    try:
        if repo_cmd == "init":
            if (SYS_CONFIG_DIR / ".git").exists():
                print(f"{YELLOW}This directory is already a git repository.{NC}")
                return
            run_cmd(["git", "init"], cwd=SYS_CONFIG_DIR)
            (SYS_CONFIG_DIR / ".gitignore").write_text("config.yaml\nstate/\n")
            run_cmd(["git", "add", "."], cwd=SYS_CONFIG_DIR)
            run_cmd(["git", "commit", "-m", "Initial wcli-config setup"], cwd=SYS_CONFIG_DIR)
            print(f"{GREEN}✓ Git repository initialized in {SYS_CONFIG_DIR}{NC}")
            print("Add a remote with: git remote add origin <url>")

        elif repo_cmd == "clone":
            if not args.url:
                print(f"{RED}Error: --url is required for clone.{NC}")
                return
            if SYS_CONFIG_DIR.exists():
                print(f"{RED}Error: {SYS_CONFIG_DIR} already exists. Remove or move it first.{NC}")
                return
            run_cmd(["git", "clone", args.url, str(SYS_CONFIG_DIR)])
            print(f"{GREEN}✓ Repository cloned to {SYS_CONFIG_DIR}{NC}")
            print("Run 'wcli sync' to apply.")

        # All other commands require an existing repo
        elif not (SYS_CONFIG_DIR / ".git").exists():
            print(f"{RED}Error: Not a git repository. Run 'wcli repo init' first.{NC}")
            return
            
        elif repo_cmd == "push":
            msg = args.message or f"Update wcli-config from {os.uname().nodename}"
            run_cmd(["git", "add", "."], cwd=SYS_CONFIG_DIR)
            run_cmd(["git", "commit", "-m", msg], cwd=SYS_CONFIG_DIR, check=False) # Allow empty commit
            print(f"{BLUE}Pushing to remote...{NC}")
            subprocess.run(["git", "push"], cwd=SYS_CONFIG_DIR, check=True) # Stream output
            print(f"{GREEN}✓ Changes pushed successfully!{NC}")

        elif repo_cmd == "pull":
            print(f"{BLUE}Pulling updates from remote...{NC}")
            subprocess.run(["git", "pull"], cwd=SYS_CONFIG_DIR, check=True) # Stream output
            print(f"{GREEN}✓ Updates pulled successfully!{NC}")
            print("Run 'wcli sync' to apply any new package changes.")
                
        elif repo_cmd == "status":
            print(f"{BLUE}Repository Status:{NC}")
            subprocess.run(["git", "status"], cwd=SYS_CONFIG_DIR)
            
    except subprocess.CalledProcessError as e:
        print(f"{RED}Error running git command '{repo_cmd}':{NC}")
        print(e.stderr)
        print(e.stdout)
    except Exception as e:
        print(f"{RED}An unexpected error occurred: {e}{NC}")

# <-- CHANGE: This is the new, unified backup command -->
def cmd_backup(provider, args):
    """
    Wrapper for Snapper or Timeshift commands.
    """
    # --- Auto-detect tool ---
    tool_cmd = None
    if shutil.which("snapper"):
        tool_cmd = ["sudo", "snapper"]
        tool_name = "snapper"
    elif shutil.which("timeshift"):
        tool_cmd = ["sudo", "timeshift"]
        tool_name = "timeshift"
    else:
        print(f"{RED}Error: No snapshot tool found.{NC}")
        deps = provider.get_deps()
        print(f"Please install 'snapper' ({deps.get('snapper')})")
        print(f"or 'timeshift' ({deps.get('timeshift')}).")
        return

    print(f"{BLUE}Using: {tool_name}{NC}")
    cmd = tool_cmd
    
    try:
        if args.list:
            cmd.append("list")
            
        elif args.create:
            comment = args.message or "wcli manual backup"
            if tool_name == "snapper":
                cmd.extend(["create", "--description", comment])
            else: # timeshift
                cmd.extend(["--create", "--comments", comment, "--scripted"])
            
        elif args.restore:
            if tool_name == "snapper":
                print(f"{YELLOW}Snapper restore is complex (requires booting from snapshot).{NC}")
                print("Listing snapshots. Please use 'snapper rollback <id>' manually.")
                cmd.append("list")
            else: # timeshift
                cmd.append("--restore")
                if args.snapshot:
                    cmd.extend(["--snapshot", args.snapshot])
            
        elif args.delete:
            if not args.snapshot:
                print(f"{RED}Error: --delete requires a snapshot ID/name.{NC}")
                return
            if tool_name == "snapper":
                cmd.extend(["delete", args.snapshot])
            else: # timeshift
                cmd.extend(["--delete", "--snapshot", args.snapshot])

        elif args.check:
            if tool_name == "snapper":
                print(f"{YELLOW}Snapper does not have a 'check' command. Use 'list'.{NC}")
                cmd.append("list")
            else: # timeshift
                cmd.append("--check")
        
        # Run the constructed command
        if not run_interactive_cmd(cmd):
            print(f"{RED}Error: {tool_name} command failed.{NC}")

    except Exception as e:
        print(f"{RED}An unexpected error occurred: {e}{NC}")

# --- Main Execution ---

def main():
    # Load provider *before* parsing args
    provider = get_provider()

    parser = argparse.ArgumentParser(
        description="wcli - A multi-distro declarative CLI wrapper tool"
    )
    subparsers = parser.add_subparsers(dest="command", help="Subcommand to run")
    subparsers.required = True

    # --- init ---
    parser_init = subparsers.add_parser("init", help="Initialize wcli-config directory structure")
    parser_init.add_argument("--force", action="store_true", help="Force re-initialization")
    parser_init.set_defaults(func=cmd_init)

    # --- update ---
    parser_update = subparsers.add_parser("update", help="Update system packages")
    parser_update.set_defaults(func=lambda p, a: p.update())

    # --- install ---
    parser_install = subparsers.add_parser("install", help="Install a package")
    parser_install.add_argument("packages", nargs="+", help="Package(s) to install")
    parser_install.set_defaults(func=lambda p, a: p.install(a.packages))

    # --- remove ---
    parser_remove = subparsers.add_parser("remove", help="Remove a package")
    parser_remove.add_argument("packages", nargs="+", help="Package(s) to remove")
    parser_remove.set_defaults(func=lambda p, a: p.remove(a.packages))

    # --- search (for anything else) ---
    parser_search = subparsers.add_parser("search", help="Search for a package")
    parser_search.add_argument("package", help="Package to search for")
    parser_search.set_defaults(func=lambda p, a: p.search(a.package))

    # --- sync ---
    parser_sync = subparsers.add_parser("sync", help="Install packages to match configuration")
    parser_sync.add_argument("-d", "--dry-run", action="store_true", help="Preview changes without applying")
    parser_sync.add_argument("--prune", action="store_true", help="Remove packages not in configuration")
    parser_sync.add_argument("--force", action="store_true", help="Skip confirmation prompts")
    parser_sync.add_argument("--no-backup", action="store_true", help="Skip automatic Timeshift/Snapper backup")
    parser_sync.set_defaults(func=cmd_sync)

    # --- module ---
    parser_module = subparsers.add_parser("module", help="Manage package modules")
    module_sub = parser_module.add_subparsers(dest="module_command", required=True)
    mod_list = module_sub.add_parser("list", help="Show all available modules and their status")
    mod_list.set_defaults(func=cmd_module_list)
    mod_enable = module_sub.add_parser("enable", help="Enable a module")
    mod_enable.add_argument("name", help="Module name to enable")
    mod_enable.set_defaults(func=cmd_module_enable)
    mod_disable = module_sub.add_parser("disable", help="Disable a module")
    mod_disable.add_argument("name", help="Module name to disable")
    mod_disable.set_defaults(func=cmd_module_disable)

    # --- status ---
    parser_status = subparsers.add_parser("status", help="Show current configuration and sync status")
    parser_status.set_defaults(func=cmd_status)

    # --- repo ---
    parser_repo = subparsers.add_parser("repo", help="Manage wcli-config git repository")
    repo_sub = parser_repo.add_subparsers(dest="repo_command", required=True)
    repo_init = repo_sub.add_parser("init", help="Set up git for wcli-config (first computer)")
    repo_init.set_defaults(func=cmd_repo)
    repo_clone = repo_sub.add_parser("clone", help="Clone existing wcli-config (new computer)")
    repo_clone.add_argument("--url", help="Git repository URL to clone")
    repo_clone.set_defaults(func=cmd_repo)
    repo_push = repo_sub.add_parser("push", help="Commit and push changes")
    repo_push.add_argument("-m", "--message", help="Commit message")
    repo_push.set_defaults(func=cmd_repo)
    repo_sub.add_parser("pull", help="Pull updates from other machines").set_defaults(func=cmd_repo)
    repo_sub.add_parser("status", help="Show git status").set_defaults(func=cmd_repo)
    
    # --- Timeshift (backup/restore) ---
    # <-- CHANGE: Updated argparse for backup -->
    parser_bk = subparsers.add_parser("backup", help="Manage Snapper/Timeshift backups")
    bk_group = parser_bk.add_mutually_exclusive_group(required=True)
    bk_group.add_argument("--list", action="store_true", help="List snapshots")
    bk_group.add_argument("--create", action="store_true", help="Create a new snapshot")
    bk_group.add_argument("--restore", action="store_true", help="Restore a snapshot (interactive)")
    bk_group.add_argument("--delete", help="Delete a specific snapshot by ID/name", metavar="SNAPSHOT")
    bk_group.add_argument("--check", action="store_true", help="Check snapshot integrity (Timeshift only)")
    parser_bk.add_argument("-m", "--message", help="Comment/description for --create")
    parser_bk.add_argument("--snapshot", help="Snapshot ID/name for --restore (Timeshift only)")
    parser_bk.set_defaults(func=cmd_backup)

    # --- Argument Fallback for 'search' ---
    if len(sys.argv) == 2 and not sys.argv[1].startswith('-') and sys.argv[1] not in subparsers.choices:
        args = parser_search.parse_args([sys.argv[1]])
    else:
        args = parser.parse_args()

    args.func(provider, args)


if __name__ == "__main__":
    # This allows the script to find the 'providers' directory
    # when installed in /usr/local/lib/wcli/
    script_dir = Path(__file__).parent.resolve()
    sys.path.insert(0, str(script_dir))
    
    try:
        import yaml
    except ImportError:
        print(f"{RED}Error: PyYAML dependency not found.{NC}")
        print("Please install it with: pip install pyyaml")
        print("(Or 'sudo apt install python3-yaml', 'sudo dnf install python3-pyyaml', etc.)")
        sys.exit(1)
        
    main()
