#!/usr/bin/env python3
# wcli - A multi-distro declarative CLI wrapper tool
#
import os
import sys
import yaml
import subprocess
import argparse
import shutil
from pathlib import Path

# --- Configuration Paths ---
#
SYS_CONFIG_DIR = Path(os.environ.get("SYS_CONFIG_DIR", Path.home() / ".config" / "wcli-config"))
CONFIG_FILE = SYS_CONFIG_DIR / "config.yaml"
PACKAGES_DIR = SYS_CONFIG_DIR / "packages"
STATE_DIR = SYS_CONFIG_DIR / "state"
STATE_FILE = STATE_DIR / "installed.yaml"

# --- Colors ---
#
RED = '\033[0;31m'
GREEN = '\033[0;32m'
YELLOW = '\033[1;33m'
BLUE = '\033[0;34m'
NC = '\033[0m'

# --- Distro Provider Loading ---

def get_provider():
    """
    Detects the OS and imports the correct provider module.
    """
    distro_id = ""
    id_like = ""
    try:
        with open("/etc/os-release") as f:
            for line in f:
                if line.startswith("ID="):
                    distro_id = line.strip().split('=')[1].lower().strip('"')
                elif line.startswith("ID_LIKE="):
                    id_like = line.strip().split('=')[1].lower().strip('"')

        # --- FIX: More robust detection ---
        # This logic now checks ID and ID_LIKE explicitly.
        distro_name = ""
        if "fedora" in distro_id:
            from providers.fedora import Provider
            distro_name = "fedora"
        elif "arch" in distro_id:
            from providers.arch import Provider
            distro_name = "arch"
        elif "debian" in distro_id or "ubuntu" in distro_id or "pop" in distro_id or "debian" in id_like or "ubuntu" in id_like:
            from providers.debian import Provider
            distro_name = "debian"
        elif "opensuse" in distro_id:
            from providers.opensuse import Provider
            distro_name = "opensuse"
        elif "gentoo" in distro_id:
            from providers.gentoo import Provider
            distro_name = "gentoo"
        elif "void" in distro_id:
            from providers.void import Provider
            distro_name = "void"
        else:
            raise ImportError(f"No matching provider found for ID={distro_id}, ID_LIKE={id_like}")
        
        print(f"{BLUE}System detected: {distro_id} (using {distro_name} provider){NC}")
        return Provider()

    # --- FIX: Better error message for missing 'providers' ---
    except ImportError as e:
        print(f"{RED}Error: A provider module could not be imported.{NC}")
        print(f"{YELLOW}This almost always means the 'providers' directory is missing from the install location (e.g., /usr/local/lib/wcli/).{NC}")
        print(f"Details: {e}")
        print("Please re-run the install.sh script from the source directory that contains both 'wcli' and the 'providers' folder.")
        sys.exit(1)
    except (FileNotFoundError, UnboundLocalError) as e:
        print(f"{RED}Error: Cannot detect distribution. /etc/os-release not found or is unreadable.{NC}")
        print(f"Details: {e}")
        sys.exit(1)

# --- Core Logic Functions ---

def load_config() -> dict:
    """Loads the main config.yaml file."""
    if not CONFIG_FILE.exists():
        print(f"{RED}Error: Configuration file not found: {CONFIG_FILE}{NC}")
        print("Run 'wcli init' to create one.")
        sys.exit(1)
    try:
        with open(CONFIG_FILE, 'r') as f:
            return yaml.safe_load(f) or {}
    except Exception as e:
        print(f"{RED}Error loading {CONFIG_FILE}: {e}{NC}")
        sys.exit(1)

def write_config(config: dict):
    """Writes to the main config.yaml file."""
    try:
        SYS_CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        with open(CONFIG_FILE, 'w') as f:
            yaml.dump(config, f, sort_keys=False)
    except Exception as e:
        print(f"{RED}Error writing {CONFIG_FILE}: {e}{NC}")
        sys.exit(1)

def get_declared_packages(config: dict) -> dict:
    """
    Parses all YAMLs to get a dictionary of all declared package lists.
    """
    package_lists = {
        "packages": set(),
        "arch_aur": set(),
        "fedora_copr": {},
        "debian_ppa": {},
        "opensuse_obs": {},
        "gentoo_overlay": {},
        "void_src": set(),
    }
    excluded_packages = set()
    hostname = config.get('host', '')

    def load_pkgs_from_file(file_path):
        if file_path.exists():
            try:
                with open(file_path, 'r') as f:
                    data = yaml.safe_load(f)
                    if not data:
                        return
                    
                    # Handle set-like lists
                    for key in ["packages", "arch_aur", "void_src"]:
                        if key in data and data[key]:
                            package_lists[key].update(data[key])
                    
                    # Handle map-like lists
                    for key in ["fedora_copr", "debian_ppa", "opensuse_obs", "gentoo_overlay"]:
                         if key in data and data[key]:
                            for repo, pkgs in data[key].items():
                                if repo not in package_lists[key]:
                                    package_lists[key][repo] = set()
                                package_lists[key][repo].update(pkgs)

                    if "exclude" in data and data["exclude"]:
                        excluded_packages.update(data["exclude"])
                        
            except Exception as e:
                print(f"{YELLOW}Warning: Could not parse {file_path}: {e}{NC}")

    # 1. Load base packages
    load_pkgs_from_file(PACKAGES_DIR / "base.yaml")

    # 2. Load host-specific packages
    host_file = PACKAGES_DIR / "hosts" / f"{hostname}.yaml"
    load_pkgs_from_file(host_file)

    # 3. Load enabled module packages
    if config.get("enabled_modules"):
        for module in config["enabled_modules"]:
            module_file = PACKAGES_DIR / "modules" / f"{module}.yaml"
            load_pkgs_from_file(module_file)

    # 4. Load additional packages from config
    if config.get("additional_packages"):
        package_lists["packages"].update(config["additional_packages"])

    # 5. Apply exclusions
    package_lists["packages"] -= excluded_packages
    
    return package_lists

def run_cmd(cmd: list, cwd: Path = None, check: bool = True) -> subprocess.CompletedProcess:
    """Helper to run a non-interactive command and capture output."""
    return subprocess.run(cmd, cwd=cwd, check=check, text=True, capture_output=True, errors='ignore')

# <-- NEW: Command runner for interactive commands like 'list' or 'restore' -->
def run_interactive_cmd(cmd: list, cwd: Path = None, check: bool = True) -> bool:
    """Helper to run an interactive command that streams output."""
    try:
        # Runs the command and streams STDOUT/STDERR to the user's terminal
        subprocess.run(cmd, cwd=cwd, check=check)
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False
    except KeyboardInterrupt:
        print(f"\n{YELLOW}Command cancelled.{NC}")
        return False

# <-- CHANGE: Renamed to be generic -->
def create_auto_snapshot():
    """Creates a pre-sync snapshot using snapper or timeshift."""
    
    comment = "wcli-sync auto-snapshot"
    
    # --- NEW: Snapper and Timeshift auto-detection ---
    if shutil.which("snapper"):
        print(f"{BLUE}Using snapper to create snapshot...{NC}")
        try:
            # Snapper's 'create' command is designed for this
            run_cmd(["sudo", "snapper", "create", "--type", "pre", "--description", comment, "--cleanup-algorithm", "timeline"])
            print(f"{GREEN}Snapper snapshot created successfully{NC}")
        except (subprocess.CalledProcessError, FileNotFoundError):
            print(f"{YELLOW}Warning: Failed to create snapper snapshot. Continuing anyway...{NC}")
            
    elif shutil.which("timeshift"):
        print(f"{BLUE}Using timeshift to create snapshot...{NC}")
        try:
            run_cmd(["sudo", "timeshift", "--create", "--comments", comment, "--scripted"])
            print(f"{GREEN}Timeshift snapshot created successfully{NC}")
        except (subprocess.CalledProcessError, FileNotFoundError):
            print(f"{YELLOW}Warning: Failed to create timeshift snapshot. Continuing anyway...{NC}")
            
    else:
        print(f"{YELLOW}Warning: No snapshot tool (snapper, timeshift) found. Skipping snapshot.{NC}")

# --- Command Functions ---

def cmd_sync(provider, args):
    """
    Declarative sync command.
    """
    print(f"{BLUE}Loading package configuration...{NC}")
    config = load_config()
    
    all_package_lists = get_declared_packages(config)
    declared_packages = all_package_lists["packages"]
    
    installed_packages = provider.get_installed_packages()

    to_install = list(declared_packages - installed_packages)
    to_remove = []

    if args.prune:
        if STATE_FILE.exists():
            try:
                with open(STATE_FILE, 'r') as f:
                    managed_packages = set(yaml.safe_load(f).get("packages", []))
                
                # Find packages that *we* managed but are no longer declared
                to_remove = list((managed_packages - declared_packages) & installed_packages)
            except Exception as e:
                 print(f"{YELLOW}Warning: Could not read state file {STATE_FILE}. Cannot prune. {e}{NC}")
        else:
            print(f"{YELLOW}Warning: State file not found. Cannot prune.{NC}")
    
    # --- Helper Package Logic ---
    helpers_to_run = {
        "aur": (provider.install_aur, list(all_package_lists["arch_aur"])),
        "copr": (provider.install_copr, all_package_lists["fedora_copr"]),
        "ppa": (provider.install_ppa, all_package_lists["debian_ppa"]),
        "obs": (provider.install_obs, all_package_lists["opensuse_obs"]),
        "overlay": (provider.install_overlay, all_package_lists["gentoo_overlay"]),
        "src": (provider.install_src, list(all_package_lists["void_src"])),
    }
    
    # Display summary
    print(f"\n{BLUE}=== Sync Summary ==={NC}")
    
    print(f"{BLUE}--- Official Repos ---{NC}")
    if to_install:
        print(f"{GREEN}Packages to install ({len(to_install)}):{NC}")
        for pkg in to_install: print(f"  {pkg}")
    else:
        print(f"{GREEN}No official packages to install{NC}")
    
    if to_remove:
        print(f"\n{YELLOW}Packages to remove ({len(to_remove)}):{NC}")
        for pkg in to_remove: print(f"  {pkg}")
    elif args.prune:
        print(f"{GREEN}No official packages to remove{NC}")

    # --- Helper Summary ---
    total_helpers = 0
    for name, (func, packages) in helpers_to_run.items():
        if packages:
            total_helpers += 1
            print(f"\n{BLUE}--- Helper: {name.upper()} ---{NC}")
            print(f"{GREEN}Packages to install ({len(packages)}):{NC}")
            if isinstance(packages, dict):
                for repo, pkgs in packages.items():
                    print(f"  From {repo}: {', '.join(pkgs)}")
            else:
                for pkg in packages: print(f"  {pkg}")

    if not to_install and not to_remove and total_helpers == 0:
        print(f"\n{GREEN}System is already in sync!{NC}")
        return

    if args.dry_run:
        print(f"\n{BLUE}Dry run - no changes made{NC}")
        return

    if not args.force:
        choice = input("\nApply these changes? [y/N] ")
        if not choice.lower().startswith('y'):
            print(f"{YELLOW}Cancelled{NC}")
            return

    # <-- CHANGE: Call the new generic snapshot function -->
    if not args.no_backup:
        create_auto_snapshot()

    # --- Run Installers ---
    
    # 1. Official Packages
    if to_install:
        print(f"\n{BLUE}Installing official packages...{NC}")
        if provider.install(to_install):
            print(f"{GREEN}Packages installed successfully{NC}")
        else:
            print(f"{RED}Error: Failed to install official packages{NC}")
            
    if to_remove:
        print(f"\n{BLUE}Removing packages...{NC}")
        if provider.remove(to_remove):
            print(f"{GREEN}Packages removed successfully{NC}")
        else:
            print(f"{RED}Error: Failed to remove packages{NC}")

    # 2. Helper Packages
    for name, (func, packages) in helpers_to_run.items():
        if packages:
            print(f"\n{BLUE}Installing {name.upper()} packages...{NC}")
            if func(packages): # Call the provider's function
                print(f"{GREEN}{name.upper()} packages installed successfully{NC}")
            else:
                print(f"{RED}Error: Failed to install {name.upper()} packages{NC}")

    # TODO: Post-install hooks
    
    print(f"\n{BLUE}Updating state file...{NC}")
    STATE_DIR.mkdir(parents=True, exist_ok=True)
    try:
        # We only track official packages in the state file for pruning
        with open(STATE_FILE, 'w') as f:
            yaml.dump({"packages": sorted(list(declared_packages))}, f)
    except Exception as e:
        print(f"{RED}Error writing state file {STATE_FILE}: {e}{NC}")
        
    print(f"\n{GREEN}Sync complete!{NC}")

def cmd_module_list(provider, args):
    """
    Lists all available modules and their status.
    """
    config = load_config()
    enabled_modules = set(config.get("enabled_modules", []))
    print(f"{BLUE}=== Available Modules ==={NC}\n")

    try:
        for module_file in (PACKAGES_DIR / "modules").glob("*.yaml"):
            module_name = module_file.stem
            try:
                with open(module_file, 'r') as f:
                    data = yaml.safe_load(f) or {}
            except Exception as e:
                print(f"{YELLOW}Warning: Could not parse {module_file}: {e}{NC}")
                continue
            
            desc = data.get("description", "No description")
            conflicts = ", ".join(data.get("conflicts", []))

            # Get counts for all package types
            pkg_counts = []
            if data.get("packages"):
                pkg_counts.append(f"Packages: {len(data['packages'])}")
            if data.get("arch_aur"):
                pkg_counts.append(f"AUR: {len(data['arch_aur'])}")
            if data.get("fedora_copr"):
                pkg_counts.append(f"COPR: {len(data['fedora_copr'])}")
            if data.get("debian_ppa"):
                pkg_counts.append(f"PPA: {len(data['debian_ppa'])}")
            # (add more for OBS, Gentoo, Void)
            
            if module_name in enabled_modules:
                status = f"{GREEN}enabled{NC}"
            else:
                status = f"{YELLOW}disabled{NC}"
                
            print(f"  {BLUE}{module_name}{NC} [{status}]")
            print(f"    {desc}")
            print(f"    {' | '.join(pkg_counts)}")
            if conflicts:
                print(f"    {RED}Conflicts with: {conflicts}{NC}")
            print("")
    except FileNotFoundError:
        print(f"{YELLOW}No modules directory found at {PACKAGES_DIR / 'modules'}{NC}")

def cmd_module_enable(provider, args):
    """
    Enables a module in config.yaml.
    """
    config = load_config()
    module_name = args.name
    module_file = PACKAGES_DIR / "modules" / f"{module_name}.yaml"

    if not module_file.exists():
        print(f"{RED}Error: Module '{module_name}' not found at {module_file}{NC}")
        sys.exit(1)

    enabled_modules = set(config.get("enabled_modules", []))
    if module_name in enabled_modules:
        print(f"{YELLOW}Module '{module_name}' is already enabled{NC}")
        return

    # Check for conflicts
    try:
        with open(module_file, 'r') as f:
            data = yaml.safe_load(f) or {}
    except Exception as e:
        print(f"{RED}Error reading module {module_file}: {e}{NC}")
        return
    
    conflicts = data.get("conflicts", [])
    if conflicts:
        for conflict in conflicts:
            if conflict in enabled_modules:
                print(f"{RED}Warning: '{module_name}' conflicts with enabled module '{conflict}'{NC}")
                choice = input(f"Disable '{conflict}' and enable '{module_name}'? [y/N] ")
                if choice.lower().startswith('y'):
                    enabled_modules.remove(conflict)
                else:
                    print(f"{YELLOW}Cancelled{NC}")
                    return

    enabled_modules.add(module_name)
    config["enabled_modules"] = sorted(list(enabled_modules))
    write_config(config)
    print(f"{GREEN}Module '{module_name}' enabled{NC}")
    print("Run 'wcli sync' to install packages")

def cmd_module_disable(provider, args):
    """
    Disables a module in config.yaml.
    """
    config = load_config()
    module_name = args.name
    enabled_modules = set(config.get("enabled_modules", []))

    if module_name not in enabled_modules:
        print(f"{YELLOW}Module '{module_name}' is not enabled{NC}")
        return

    enabled_modules.remove(module_name)
    config["enabled_modules"] = sorted(list(enabled_modules))
    write_config(config)
    print(f"{GREEN}Module '{module_name}' disabled{NC}")
    print("Run '
