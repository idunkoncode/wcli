#!/usr/bin/env bash
# sys-sync - A multi-distro declarative CLI wrapper tool

set -euo pipefail

# Configuration paths
SYS_CONFIG_DIR="${SYS_CONFIG_DIR:-${HOME}/.config/sys-config}"
CONFIG_FILE="${SYS_CONFIG_DIR}/config.yaml"
PACKAGES_DIR="${SYS_CONFIG_DIR}/packages"
STATE_DIR="${SYS_CONFIG_DIR}/state"
STATE_FILE="${STATE_DIR}/installed.yaml"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# ============================================================================
# DISTRO-SPECIFIC CONFIGURATION
# ============================================================================

DISTRO_ID=""
CMD_INSTALL=""
CMD_REMOVE=""
CMD_UPDATE=""
CMD_SEARCH=""
CMD_LIST_INSTALLED=""
DEP_YQ_INSTALL=""
DEP_TS_INSTALL=""

# Detect the distro
if [ -f /etc/os-release ]; then
    . /etc/os-release
    DISTRO_ID=$ID
    # Handle ID_LIKE for derivatives (e.g., Pop!_OS, Linux Mint)
    if [ -z "$DISTRO_ID" ] && [ -n "$ID_LIKE" ]; then
        DISTRO_ID=$ID_LIKE
    fi
else
    echo -e "${RED}Error: Cannot detect distribution. /etc/os-release not found.${NC}" >&2
    exit 1
fi

case $DISTRO_ID in
    fedora)
        echo -e "${BLUE}Fedora system detected${NC}"
        CMD_INSTALL="sudo dnf install -y"
        CMD_REMOVE="sudo dnf remove -y"
        CMD_UPDATE="sudo dnf update -y"
        CMD_SEARCH="dnf search"
        CMD_LIST_INSTALLED="rpm -qa --qf '%{NAME}\n'"
        DEP_YQ_INSTALL="sudo dnf install yq"
        DEP_TS_INSTALL="sudo dnf install timeshift"
        ;;
    opensuse)
        echo -e "${BLUE}Opensuse system detected${NC}"
        CMD_INSTALL="sudo zypper install -y"
        CMD_REMOVE="sudo zypper remove -y"
        CMD_UPDATE="sudo zypper update -y"
        CMD_SEARCH="zypper search"
        CMD_LIST_INSTALLED="rpm -qa --qf '%{NAME}\n'"
        DEP_YQ_INSTALL="sudo zypper install yq"
        DEP_TS_INSTALL="sudo zypper install timeshift"
        ;;
    arch)
        echo -e "${BLUE}Arch Linux system detected${NC}"
        # Assumes paru (or another AUR helper) for update/search
        # Uses pacman for official sync operations
        CMD_INSTALL="sudo pacman -S --noconfirm --needed"
        CMD_REMOVE="sudo pacman -Rs --noconfirm"
        CMD_UPDATE="paru -Syu --noconfirm"
        CMD_SEARCH="paru"
        CMD_LIST_INSTALLED="pacman -Qq"
        DEP_YQ_INSTALL="sudo pacman -S go-yq"
        DEP_TS_INSTALL="sudo pacman -S timeshift"
        ;;
    debian|ubuntu|pop)
        echo -e "${BLUE}Debian-based system detected ($ID)${NC}"
        # Set non-interactive to avoid prompts during install/remove
        export DEBIAN_FRONTEND=noninteractive
        CMD_INSTALL="sudo apt install -y"
        CMD_REMOVE="sudo apt remove -y"
        CMD_UPDATE="sudo apt update && sudo apt upgrade -y"
        CMD_SEARCH="apt search"
        CMD_LIST_INSTALLED="dpkg-query -W -f='${binary:Package}\n'"
        DEP_YQ_INSTALL="sudo apt install yq"
        DEP_TS_INSTALL="sudo apt install timeshift"
        ;;
    *)
        echo -e "${RED}Error: Unsupported distribution: $ID${NC}" >&2
        echo "This script currently supports: fedora, arch, debian, ubuntu, pop" >&2
        exit 1
        ;;
esac

# ============================================================================

# Helper function
print_help() {
  cat << EOF
sys-sync - A multi-distro declarative CLI wrapper tool

Setup:
  sys-sync init                  - Initialize sys-config directory structure

Package Management:
  sys-sync update                - Update system (uses dnf, paru, or apt)
  sys-sync <package-name>        - Search for package
  sys-sync install <package>     - Install package natively
  sys-sync remove <package>      - Remove package natively

Declarative Package Management:
  sys-sync sync                  - Install packages to match configuration
  sys-sync sync -d, --dry-run    - Preview changes without applying
  sys-sync sync --prune          - Remove packages not in configuration
  sys-sync sync --force          - Skip confirmation prompts
  sys-sync sync --no-backup      - Skip automatic Timeshift backup
  sys-sync status                - Show current configuration and sync status

  sys-sync module list           - Show all available modules and their status
  sys-sync module enable <name>    - Enable a module
  sys-sync module disable <name>   - Disable a module

Timeshift Commands:
  (Requires Timeshift: ${DEP_TS_INSTALL})
  sys-sync backup                - Create snapshot (timeshift --create)

Repository Management:
  sys-sync repo init             - Set up git for sys-config (first computer)
  sys-sync repo clone            - Clone existing sys-config (new computer)
  sys-sync repo push             - Commit and push changes
  sys-sync repo pull             - Pull updates from other machines
  sys-sync repo status           - Show git status
  sys-sync backup list           - List snapshots (timeshift --list)
  sys-sync restore               - Restore snapshot interactively (timeshift --restore)
  sys-sync restore <snapshot>    - Restore specific snapshot (timeshift --restore --snapshot)
  sys-sync -d <snapshot>         - Delete snapshot (timeshift --delete --snapshot)
  sys-sync -c backup             - Check snapshot integrity (timeshift --check)

  help                           - Show this help message
EOF
}

# Check if yq is installed
check_yq() {
  if ! command -v yq &> /dev/null; then
    echo -e "${RED}Error: yq is required but not installed${NC}" >&2
    echo "Install with: ${DEP_YQ_INSTALL}" >&2
    exit 1
  fi
}

# Check if timeshift is installed
check_timeshift() {
  if ! command -v timeshift &> /dev/null; then
    echo -e "${RED}Error: timeshift is required but not installed${NC}" >&2
    echo "Install with: ${DEP_TS_INSTALL}" >&2
    exit 1
  fi
}

# Load config.yaml
load_config() {
  if [ ! -f "$CONFIG_FILE" ]; then
    echo -e "${RED}Error: Configuration file not found: $CONFIG_FILE${NC}" >&2
    echo "Run 'sys-sync init' to create one." >&2
    exit 1
  fi
  cat "$CONFIG_FILE"
}

# Get all packages that should be installed
get_declared_packages() {
  check_yq

  local config
  config=$(load_config)

  local hostname
  hostname=$(echo "$config" | yq '.host')

  local enabled_modules
  enabled_modules=$(echo "$config" | yq '.enabled_modules[]' 2>/dev/null || true)

  local all_packages=()
  local excluded_packages=()

  # 1. Load base packages
  if [ -f "${PACKAGES_DIR}/base.yaml" ]; then
    while IFS= read -r pkg; do
      [ -n "$pkg" ] && all_packages+=("$pkg")
    done < <(yq '.packages[]?' "${PACKAGES_DIR}/base.yaml" 2>/dev/null)
  fi

  # 2. Load host-specific packages
  local host_file="${PACKAGES_DIR}/hosts/${hostname}.yaml"
  if [ -f "$host_file" ]; then
    while IFS= read -r pkg; do
      [ -n "$pkg" ] && all_packages+=("$pkg")
    done < <(yq '.packages[]?' "$host_file" 2>/dev/null)

    # Get exclusions
    while IFS= read -r pkg; do
      [ -n "$pkg" ] && excluded_packages+=("$pkg")
    done < <(yq '.exclude[]?' "$host_file" 2>/dev/null)
  fi

  # 3. Load enabled module packages
  if [ -n "$enabled_modules" ]; then
    while IFS= read -r module; do
      local module_file="${PACKAGES_DIR}/modules/${module}.yaml"
      if [ -f "$module_file" ]; then
        while IFS= read -r pkg; do
          [ -n "$pkg" ] && all_packages+=("$pkg")
        done < <(yq '.packages[]?' "$module_file" 2>/dev/null)
      fi
    done <<< "$enabled_modules"
  fi

  # 4. Load additional packages from config
  while IFS= read -r pkg; do
    [ -n "$pkg" ] && all_packages+=("$pkg")
  done < <(echo "$config" | yq '.additional_packages[]?' 2>/dev/null)

  # Remove duplicates and excluded packages
  local unique_packages
  unique_packages=$(printf '%s\n' "${all_packages[@]}" | sort -u)

  # Filter out excluded packages
  if [ ${#excluded_packages[@]} -gt 0 ]; then
    for excluded in "${excluded_packages[@]}"; do
      unique_packages=$(echo "$unique_packages" | grep -v "^${excluded}$" || true)
    done
  fi

  echo "$unique_packages"
}

# Get currently installed packages
get_installed_packages() {
  # Use eval to correctly handle commands with quotes
  eval "$CMD_LIST_INSTALLED"
}

# Create Timeshift backup
create_backup() {
  check_timeshift
  echo -e "${BLUE}Creating Timeshift snapshot before sync...${NC}"
  if ! sudo timeshift --create --comments "sys-sync autobackup" --scripted > /dev/null 2>&1; then
    echo -e "${YELLOW}Warning: Failed to create Timeshift backup${NC}"
    echo -e "${YELLOW}Continuing anyway...${NC}"
  else
    echo -e "${GREEN}Backup created successfully${NC}"
  fi
}

# Sync packages
cmd_sync() {
  local dry_run=false
  local prune=false
  local force=false
  local no_backup=false

  # Parse flags
  while [[ $# -gt 0 ]]; do
    case $1 in
      -d|--dry-run)
        dry_run=true
        shift
        ;;
      --prune)
        prune=true
        shift
        ;;
      --force)
        force=true
        shift
        ;;
      --no-backup)
        no_backup=true
        shift
        ;;
      *)
        echo -e "${RED}Error: Unknown option: $1${NC}" >&2
        exit 1
        ;;
    esac
  done

  echo -e "${BLUE}Loading package configuration...${NC}"

  local config
  config=$(load_config)

  local enabled_modules
  enabled_modules=$(echo "$config" | yq '.enabled_modules[]' 2>/dev/null || true)

  local declared_packages
  declared_packages=$(get_declared_packages)

  local installed_packages
  installed_packages=$(get_installed_packages)

  # Find packages to install
  local to_install=()
  while IFS= read -r pkg; do
    [ -z "$pkg" ] && continue
    if ! echo "$installed_packages" | grep -q "^${pkg}$"; then
      to_install+=("$pkg")
    fi
  done <<< "$declared_packages"

  # Find packages to remove (only if pruning)
  local to_remove=()
  if [ "$prune" = true ]; then
    # Load state file to see what we previously installed
    if [ -f "$STATE_FILE" ]; then
      local managed_packages
      managed_packages=$(yq '.packages[]?' "$STATE_FILE" 2>/dev/null || true)

      while IFS= read -r pkg; do
        [ -z "$pkg" ] && continue
        if ! echo "$declared_packages" | grep -q "^${pkg}$"; then
          # Package was managed but is no longer declared
          if echo "$installed_packages" | grep -q "^${pkg}$"; then
            to_remove+=("$pkg")
          fi
        fi
      done <<< "$managed_packages"
    fi
  fi

  # Display summary
  echo ""
  echo -e "${BLUE}=== Sync Summary ===${NC}"

  if [ ${#to_install[@]} -gt 0 ]; then
    echo -e "${GREEN}Packages to install (${#to_install[@]}):${NC}"
    printf '  %s\n' "${to_install[@]}"
  else
    echo -e "${GREEN}No packages to install${NC}"
  fi

  echo ""

  if [ ${#to_remove[@]} -gt 0 ]; then
    echo -e "${YELLOW}Packages to remove (${#to_remove[@]}):${NC}"
    printf '  %s\n' "${to_remove[@]}"
  elif [ "$prune" = true ]; then
    echo -e "${GREEN}No packages to remove${NC}"
  fi

  # Exit if dry run
  if [ "$dry_run" = true ]; then
    echo ""
    echo -e "${BLUE}Dry run - no changes made${NC}"
    exit 0
  fi

  # Check if we need to run post-install hooks even if no packages to install/remove
  local need_hooks=false
  if [ -n "$enabled_modules" ]; then
    while IFS= read -r module; do
      local module_file="${PACKAGES_DIR}/modules/${module}.yaml"
      if [ -f "$module_file" ]; then
        local post_hook
        post_hook=$(yq '.post_install_hook?' "$module_file" 2>/dev/null || echo "")
        if [ -n "$post_hook" ] && [ "$post_hook" != "null" ]; then
          need_hooks=true
          break
        fi
      fi
    done <<< "$enabled_modules"
  fi

  # Exit if nothing to do and no hooks to run
  if [ ${#to_install[@]} -eq 0 ] && [ ${#to_remove[@]} -eq 0 ] && [ "$need_hooks" = false ]; then
    echo ""
    echo -e "${GREEN}System is already in sync!${NC}"
    exit 0
  fi

  # Confirm unless --force (only if there are changes to make)
  if [ "$force" = false ] && { [ ${#to_install[@]} -gt 0 ] || [ ${#to_remove[@]} -gt 0 ]; }; then
    echo ""
    read -p "Apply these changes? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      echo -e "${YELLOW}Cancelled${NC}"
      exit 0
    fi
  fi

  # Create backup unless --no-backup
  if [ "$no_backup" = false ]; then
    create_backup
  fi

  # Install packages
  if [ ${#to_install[@]} -gt 0 ]; then
    echo ""
    echo -e "${BLUE}Installing packages...${NC}"
    # Use eval to handle package groups (like @core) correctly
    if ! eval "$CMD_INSTALL" "${to_install[@]}"; then
      echo -e "${RED}Error: Failed to install packages${NC}" >&2
      exit 1
    fi
    echo -e "${GREEN}Packages installed successfully${NC}"
  fi

  # Remove packages
  if [ ${#to_remove[@]} -gt 0 ]; then
    echo ""
    echo -e "${BLUE}Removing packages...${NC}"
    if ! $CMD_REMOVE "${to_remove[@]}"; then
      echo -e "${RED}Error: Failed to remove packages${NC}" >&2
      exit 1
    fi
    echo -e "${GREEN}Packages removed successfully${NC}"
  fi

  # Run post-install hooks for enabled modules
  if [ -n "$enabled_modules" ]; then
    while IFS= read -r module; do
      local module_file="${PACKAGES_DIR}/modules/${module}.yaml"
      if [ -f "$module_file" ]; then
        local post_hook
        post_hook=$(yq '.post_install_hook?' "$module_file" 2>/dev/null || echo "")

        if [ -n "$post_hook" ] && [ "$post_hook" != "null" ]; then
          local hook_script="${SYS_CONFIG_DIR}/${post_hook}"
          if [ -f "$hook_script" ]; then
            echo ""
            echo -e "${BLUE}Running post-install hook for '${module}'...${NC}"
            if sudo bash "$hook_script"; then
              echo -e "${GREEN}Post-install hook completed successfully${NC}"
            else
              echo -e "${YELLOW}Warning: Post-install hook failed for '${module}'${NC}"
            fi
          fi
        fi
      fi
    done <<< "$enabled_modules"
  fi

  # Update state file
  mkdir -p "$STATE_DIR"
  { echo "packages:"; echo "$declared_packages" | sed 's/^/  - /'; } > "$STATE_FILE"

  echo ""
  echo -e "${GREEN}Sync complete!${NC}"
}

# Module list command
cmd_module_list() {
  check_yq

  local config
  config=$(load_config)

  local enabled_modules
  enabled_modules=$(echo "$config" | yq '.enabled_modules[]' 2>/dev/null || echo "")

  echo -e "${BLUE}=== Available Modules ===${NC}"
  echo ""

  for module_file in "${PACKAGES_DIR}/modules"/*.yaml; do
    if [ -f "$module_file" ]; then
      local module_name
      module_name=$(basename "$module_file" .yaml)

      local description
      description=$(yq '.description?' "$module_file" 2>/dev/null)

      local conflicts
      conflicts=$(yq '.conflicts[]?' "$module_file" 2>/dev/null | tr '\n' ',' | sed 's/,$//')

      local pkg_count
      pkg_count=$(yq '.packages | length' "$module_file" 2>/dev/null)

      local status="disabled"
      if echo "$enabled_modules" | grep -q "^${module_name}$"; then
        status="${GREEN}enabled${NC}"
      else
        status="${YELLOW}disabled${NC}"
      fi

      echo -e "  ${BLUE}${module_name}${NC} [${status}]"
      echo -e "    ${description}"
      echo -e "    Packages: ${pkg_count}"
      if [ -n "$conflicts" ]; then
        echo -e "    ${RED}Conflicts with: ${conflicts}${NC}"
      fi
      echo ""
    fi
  done
}

# Module enable command
cmd_module_enable() {
  check_yq

  local module_name="$1"
  local module_file="${PACKAGES_DIR}/modules/${module_name}.yaml"

  if [ ! -f "$module_file" ]; then
    echo -e "${RED}Error: Module '${module_name}' not found${NC}" >&2
    echo "Run 'sys-sync module list' to see available modules" >&2
    exit 1
  fi

  local config
  config=$(load_config)

  # Check if already enabled
if echo "$config" | yq -e '.enabled_modules[] | select(. == "'${module_name}'")' | grep -q . > /dev/null 2>&1; then
    echo -e "${YELLOW}Module '${module_name}' is already enabled${NC}"
    exit 0
  fi

  # Check for conflicts
  local conflicts
  conflicts=$(yq '.conflicts[]?' "$module_file" 2>/dev/null || true)

  if [ -n "$conflicts" ]; then
    local enabled_modules
    enabled_modules=$(echo "$config" | yq '.enabled_modules[]' 2>/dev/null || true)

    while IFS= read -r conflict; do
      if echo "$enabled_modules" | grep -q "^${conflict}$"; then
        echo -e "${RED}Warning: Module '${module_name}' conflicts with enabled module '${conflict}'${NC}"
        read -p "Disable '${conflict}' and enable '${module_name}'? [y/N] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
          # Disable conflicting module
          yq -i ".enabled_modules = (.enabled_modules - [\"${conflict}\"])" "$CONFIG_FILE"
        else
          echo -e "${YELLOW}Cancelled${NC}"
          exit 0
        fi
      fi
    done <<< "$conflicts"
  fi

  # Enable module
  yq -i ".enabled_modules += [\"${module_name}\"]" "$CONFIG_FILE"

  echo -e "${GREEN}Module '${module_name}' enabled${NC}"
  echo "Run 'sys-sync sync' to install packages"
}

# Module disable command
cmd_module_disable() {
  check_yq

  local module_name="$1"

  local config
  config=$(load_config)

  # Check if enabled
if ! echo "$config" | yq -e '.enabled_modules[] | select(. == "'${module_name}'")' | grep -q . > /dev/null 2>&1; then
    echo -e "${YELLOW}Module '${module_name}' is not enabled${NC}"
    exit 0
  fi

  # Disable module
  yq -i ".enabled_modules = (.enabled_modules - [\"${module_name}\"])" "$CONFIG_FILE"

  echo -e "${GREEN}Module '${module_name}' disabled${NC}"
  echo "Run 'sys-sync sync --prune' to remove packages"
}

# Status command
cmd_status() {
  check_yq

  local config
  config=$(load_config)

  local hostname
  hostname=$(echo "$config" | yq '.host')

  local enabled_modules
  enabled_modules=$(echo "$config" | yq '.enabled_modules[]' 2>/dev/null || true)

  local auto_prune
  auto_prune=$(echo "$config" | yq '.auto_prune')

  echo -e "${BLUE}=== Configuration Status ===${NC}"
  echo ""
  echo -e "  Distro: ${GREEN}${DISTRO_ID}${NC}"
  echo -e "  Hostname: ${GREEN}${hostname}${NC}"
  echo -e "  Auto-prune: ${auto_prune}"
  echo ""

  echo -e "${BLUE}Enabled Modules:${NC}"
  if [ -z "$enabled_modules" ]; then
    echo "  (none)"
  else
    while IFS= read -r module; do
      echo "  - $module"
    done <<< "$enabled_modules"
  fi
  echo ""

  # Check for conflicts
  local has_conflicts=false
  while IFS= read -r module1; do
    local module_file1="${PACKAGES_DIR}/modules/${module1}.yaml"
    if [ -f "$module_file1" ]; then
      local conflicts1
      conflicts1=$(yq '.conflicts[]?' "$module_file1" 2>/dev/null || true)

      while IFS= read -r conflict; do
        if echo "$enabled_modules" | grep -q "^${conflict}$"; then
          if [ "$has_conflicts" = false ]; then
            echo -e "${RED}Conflicts detected:${NC}"
            has_conflicts=true
          fi
          echo -e "  ${RED}⚠${NC} Module '${module1}' conflicts with '${conflict}'"
        fi
      done <<< "$conflicts1"
    fi
  done <<< "$enabled_modules"

  if [ "$has_conflicts" = true ]; then
    echo ""
  fi

  # Package summary
  local declared_packages
  declared_packages=$(get_declared_packages)

  local declared_count
  declared_count=$(echo "$declared_packages" | wc -l)

  local installed_packages
  installed_packages=$(get_installed_packages)

  local to_install=0
  while IFS= read -r pkg; do
    [ -z "$pkg" ] && continue
    if ! echo "$installed_packages" | grep -q "^${pkg}$"; then
      ((to_install++))
    fi
  done <<< "$declared_packages"

  echo -e "${BLUE}Packages:${NC}"
  echo "  Declared: ${declared_count}"
  echo "  To install: ${to_install}"

  if [ "$to_install" -gt 0 ]; then
    echo ""
    echo -e "${YELLOW}System is out of sync. Run 'sys-sync sync' to install packages.${NC}"
  else
    echo ""
    echo -e "${GREEN}System is in sync!${NC}"
  fi
}

# Initialize sys-config directory structure
cmd_init() {
  echo -e "${BLUE}Initializing sys-config directory structure...${NC}"
  echo ""

  # Check if sys-config already exists
  if [ -d "$SYS_CONFIG_DIR" ]; then
    echo -e "${YELLOW}Warning: $SYS_CONFIG_DIR already exists${NC}"
    read -p "Do you want to reinitialize? This will backup existing files. [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      echo -e "${YELLOW}Cancelled${NC}"
      exit 0
    fi

    # Backup existing directory
    local backup_dir="${SYS_CONFIG_DIR}.backup.$(date +%s)"
    echo -e "${BLUE}Backing up existing directory to: ${backup_dir}${NC}"
    mv "$SYS_CONFIG_DIR" "$backup_dir"
  fi

  # Create directory structure
  mkdir -p "$SYS_CONFIG_DIR"
  mkdir -p "$PACKAGES_DIR/hosts"
  mkdir -p "$PACKAGES_DIR/modules"
  mkdir -p "$STATE_DIR"
  mkdir -p "$SYS_CONFIG_DIR/scripts"

  # Get hostname
  local hostname
  hostname=$(hostname)

  # Create config.yaml
  cat > "$CONFIG_FILE" << EOF
# Main configuration for sys-sync declarative package management
# Edit this file to customize your system configuration

# Hostname of this machine
host: $hostname

# List of enabled modules
# Enable modules with: sys-sync module enable <module-name>
enabled_modules: []

# Additional packages not in any module
additional_packages: []

# Automatically remove unmanaged packages during sync
auto_prune: false
EOF

  echo -e "${GREEN}✓${NC} Created config.yaml with hostname: $hostname"

  # Create base.yaml (distro-specific)
  case $DISTRO_ID in
    fedora)
      cat > "$PACKAGES_DIR/base.yaml" << 'EOF'
# Base packages for Fedora
description: Base packages for all Fedora machines
packages:
  - "@core"
  - kernel
  - linux-firmware
  - NetworkManager
  - vim-enhanced
  - git
  - yq
EOF
      ;;
    arch)
      cat > "$PACKAGES_DIR/base.yaml" << 'EOF'
# Base packages for Arch
description: Base packages for all Arch machines
packages:
  - base
  - linux
  - linux-firmware
  - networkmanager
  - vim
  - git
  - go-yq
EOF
      ;;
    debian|ubuntu|pop)
      cat > "$PACKAGES_DIR/base.yaml" << 'EOF'
# Base packages for Debian/Ubuntu
description: Base packages for all Debian-based machines
packages:
  - build-essential
  - linux-image-generic
  - network-manager
  - vim
  - git
  - yq
EOF
      ;;
  esac

  echo -e "${GREEN}✓${NC} Created packages/base.yaml for $DISTRO_ID"

  # Create host-specific package file
  cat > "$PACKAGES_DIR/hosts/${hostname}.yaml" << EOF
# Host-specific packages for $hostname
# Add packages unique to this machine (drivers, hardware-specific tools, etc.)
description: Packages specific to $hostname

# Packages to install on this host
# e.g., @development-tools, @c-development
packages: []

# Packages to exclude from base or modules on this host
exclude: []
EOF

  echo -e "${GREEN}✓${NC} Created packages/hosts/${hostname}.yaml"

  # Create .gitignore in state directory
  cat > "$STATE_DIR/.gitignore" << EOF
# Auto-generated state files
installed.yaml
EOF

  echo -e "${GREEN}✓${NC} Created state/.gitignore"

  # Create example module
  cat > "$PACKAGES_DIR/modules/example.yaml" << 'EOF'
# Example module template
# Copy this to create new modules, or delete it

description: Example module - customize or delete this

# List of packages in this module
packages: []

# Modules that conflict with this one
conflicts: []

# Script to run after installing packages (optional, path relative to config dir)
# e.g., scripts/my_hook.sh
post_install_hook: ""
EOF

  echo -e "${GREEN}✓${NC} Created example module"

  # Create README.md
  cat > "$SYS_CONFIG_DIR/README.md" << EOF
# sys-config

Declarative package management configuration for Linux.

## Structure

- \`config.yaml\` - Main configuration file
- \`packages/base.yaml\` - Base packages for all machines
- \`packages/hosts/\` - Host-specific package configurations
- \`packages/modules/\` - Optional package modules
- \`scripts/\` - Post-install hook scripts
- \`state/\` - Auto-generated state files (git-ignored)

## Usage

### Add base packages
Edit \`packages/base.yaml\` to add packages that should be installed on all machines.

### Add host-specific packages
Edit \`packages/hosts/${hostname}.yaml\` to add packages specific to this machine.

### Create and enable modules
1. Create a new YAML file in \`packages/modules/\`
2. Enable it with: \`sys-sync module enable <module-name>\`
3. Sync packages: \`sys-sync sync\`

### Sync packages
\`\`\`bash
sys-sync sync          # Preview and install missing packages
sys-sync sync --prune  # Also remove packages not in configuration
\`\`\`

## Git Integration

Initialize a git repository to track your configuration:

\`\`\`bash
cd $SYS_CONFIG_DIR
git init
git add .
git commit -m "Initial sys-config setup"
\`\`\`

The \`state/installed.yaml\` file is auto-generated and git-ignored.
EOF

  echo -e "${GREEN}✓${NC} Created README.md"

  echo ""
  echo -e "${GREEN}Initialization complete!${NC}"
  echo ""
  echo "Next steps:"
  echo "  1. Edit $PACKAGES_DIR/base.yaml to add your base packages"
  echo "  2. Edit $PACKAGES_DIR/hosts/${hostname}.yaml for host-specific packages"
  echo "  3. Create modules in $PACKAGES_DIR/modules/"
  echo "  4. Run 'sys-sync repo init' to version control your config (recommended)"
  echo "  5. Run 'sys-sync sync' to install packages"
}

# ============================================================================
# Git Repository Management Functions
# (These are distro-agnostic and need no changes, only path renaming)
# ============================================================================

check_git_repo() {
  if [ ! -d "$SYS_CONFIG_DIR/.git" ]; then
    return 1
  fi
  return 0
}

validate_git_url() {
  local url="$1"
  if [[ "$url" =~ ^(https://|git@).+\.git$ ]] || [[ "$url" =~ ^(https://|git@).+$ ]]; then
    return 0
  fi
  return 1
}

handle_git_error() {
  local exit_code=$1
  local operation=$2
  
  if [ $exit_code -ne 0 ]; then
    echo -e "${RED}Error during: $operation${NC}"
    
    case $operation in
      "push"|"clone")
        echo -e "${YELLOW}Authentication may have failed.${NC}"
        echo "For HTTPS URLs: You may need a Personal Access Token."
        echo "For SSH URLs: Ensure your SSH key is added to your account."
        ;;
      "pull")
        echo -e "${YELLOW}There may be merge conflicts.${NC}"
        echo "  • Run: cd $SYS_CONFIG_DIR && git status"
        echo "  • Resolve conflicts manually, then: git add . && git commit"
        ;;
    esac
    return 1
  fi
  return 0
}

cmd_repo_init() {
  cd "$SYS_CONFIG_DIR" || exit 1
  
  if check_git_repo; then
    echo -e "${YELLOW}This directory is already a git repository.${NC}"
    read -p "Reinitialize? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      echo -e "${YELLOW}Cancelled${NC}"
      exit 0
    fi
  fi
  
  echo -e "${BLUE}Setting up Git Repository...${NC}"
  read -p "Version control your sys-config with git? [Y/n] " -n 1 -r
  echo
  if [[ $REPLY =~ ^[Nn]$ ]]; then
    echo -e "${YELLOW}Skipped git setup${NC}"
    exit 0
  fi
  
  echo "On GitHub/GitLab, create a new private repository (e.g., 'sys-config')."
  echo "Do NOT initialize it with a README."
  read -p "Press Enter when done..."
  
  echo -e "${BLUE}Enter your repository URL${NC} (e.g., git@github.com:user/sys-config.git)"
  read -p "URL: " repo_url
  
  if ! validate_git_url "$repo_url"; then
    echo -e "${RED}Invalid URL format${NC}"
    exit 1
  fi
  
  echo -e "${BLUE}Setting up repository...${NC}"
  
  if [ ! -d ".git" ]; then
    git init || exit 1
  fi
  
  echo -e "${BLUE}→${NC} Adding config.yaml to .gitignore..."
  if ! grep -q "^config.yaml$" .gitignore 2>/dev/null; then
    echo "config.yaml" >> .gitignore
  fi
  
  git add .
  git commit -m "Initial sys-config setup from $(hostname)" || true
  
  if git remote get-url origin > /dev/null 2>&1; then
    git remote set-url origin "$repo_url"
  else
    git remote add origin "$repo_url"
  fi
  
  echo -e "${BLUE}→${NC} Pushing to remote...${NC}"
  if git push -u origin main 2>&1; then
    echo -e "${GREEN}✓ Repository set up successfully!${NC}"
  else
    handle_git_error $? "push"
  fi
}

cmd_repo_clone() {
  echo -e "${BLUE}Cloning sys-config Repository...${NC}"
  
  if [ -d "$SYS_CONFIG_DIR" ]; then
    echo -e "${YELLOW}sys-config directory already exists${NC}"
    read -p "Backup and replace? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      echo -e "${YELLOW}Cancelled${NC}"
      exit 0
    fi
  fi
  
  echo "Enter your sys-config repository URL:"
  read -p "URL: " repo_url
  
  if ! validate_git_url "$repo_url"; then
    echo -e "${RED}Invalid URL format${NC}"
    exit 1
  fi
  
  if [ -d "$SYS_CONFIG_DIR" ]; then
    backup_dir="${SYS_CONFIG_DIR}.backup.$(date +%s)"
    echo -e "${BLUE}→${NC} Backing up existing sys-config to: $backup_dir${NC}"
    mv "$SYS_CONFIG_DIR" "$backup_dir"
  fi
  
  echo -e "${BLUE}→${NC} Cloning from $repo_url...${NC}"
  if ! git clone "$repo_url" "$SYS_CONFIG_DIR"; then
    handle_git_error $? "clone"
    if [ -d "$backup_dir" ]; then
      mv "$backup_dir" "$SYS_CONFIG_DIR"
    fi
    exit 1
  fi
  
  cd "$SYS_CONFIG_DIR" || exit 1
  
  local current_hostname
  current_hostname=$(hostname)
  
  echo -e "${BLUE}→${NC} Configuring for host: ${GREEN}$current_hostname${NC}"
  yq -i ".host = \"$current_hostname\"" config.yaml
  
  local host_file="packages/hosts/${current_hostname}.yaml"
  if [ -f "$host_file" ]; then
    echo -e "${YELLOW}Host configuration already exists: $host_file${NC}"
  else
    echo -e "${BLUE}→${NC} Creating new host-specific configuration...${NC}"
    cat > "$host_file" << EOF
# Host-specific packages for $current_hostname
description: Packages specific to $current_hostname
packages: []
exclude: []
EOF
  fi
  
  echo -e "${GREEN}✓ sys-config cloned and configured!${NC}"
  echo "Run 'sys-sync sync' to apply your configuration."
}

cmd_repo_push() {
  cd "$SYS_CONFIG_DIR" || exit 1
  
  if ! check_git_repo; then
    echo -e "${RED}Not a git repository${NC}"
    exit 1
  fi
  
  echo -e "${BLUE}Pushing sys-config changes...${NC}"
  
  if ! git diff-index --quiet HEAD -- 2>/dev/null; then
    echo -e "${BLUE}→${NC} Changes detected"
  elif ! git diff --quiet 2>/dev/null; then
    echo -e "${BLUE}→${NC} Unstaged changes detected"
  else
    echo -e "${GREEN}No changes to commit${NC}"
    exit 0
  fi
  
  read -p "Commit message (default: 'Update'): " commit_msg
  [ -z "$commit_msg" ] && commit_msg="Update sys-config from $(hostname)"
  
  echo -e "${BLUE}→${NC} Staging, committing, and pushing...${NC}"
  git add .
  git commit -m "$commit_msg"
  
  if git push; then
    echo -e "${GREEN}✓ Changes pushed successfully!${NC}"
  else
    handle_git_error $? "push"
  fi
}

cmd_repo_pull() {
  cd "$SYS_CONFIG_DIR" || exit 1
  
  if ! check_git_repo; then
    echo -e "${RED}Not a git repository${NC}"
    exit 1
  fi
  
  echo -e "${BLUE}Pulling updates from remote...${NC}"
  
  if git pull; then
    echo -e "${GREEN}✓ Updates pulled successfully!${NC}"
    echo "Run 'sys-sync sync' to apply any new package changes"
  else
    handle_git_error $? "pull"
  fi
}

cmd_repo_status() {
  cd "$SYS_CONFIG_DIR" || exit 1
  
  if ! check_git_repo; then
    echo -e "${RED}Not a git repository${NC}"
    exit 1
  fi
  
  echo -e "${BLUE}Repository Status:${NC}"
  git status
}


# ============================================================================
# MAIN COMMAND HANDLER
# ============================================================================
case "${1:-}" in
  help|--help|-h)
    print_help
    exit 0
    ;;
  init)
    cmd_init
    exit 0
    ;;
  update)
    eval "$CMD_UPDATE"
    ;;
  install)
    if [ $# -lt 2 ]; then
      echo "Error: Please specify a package to install" >&2
      exit 1
    fi
    shift
    eval "$CMD_INSTALL" "$@"
    ;;
  remove)
    if [ $# -lt 2 ]; then
      echo "Error: Please specify a package to remove" >&2
      exit 1
    fi
    shift
    eval "$CMD_REMOVE" "$@"
    ;;
  sync)
    shift
    cmd_sync "$@"
    ;;
  module)
    case "${2:-}" in
      list)
        cmd_module_list
        ;;
      enable)
        [ $# -lt 3 ] && { echo "Error: No module name specified" >&2; exit 1; }
        cmd_module_enable "$3"
        ;;
      disable)
        [ $# -lt 3 ] && { echo "Error: No module name specified" >&2; exit 1; }
        cmd_module_disable "$3"
        ;;
      *)
        echo "Error: Unknown module command: ${2:-}" >&2
        exit 1
        ;;
    esac
    ;;
  status)
    cmd_status
    ;;
  repo)
    case "${2:-}" in
      init)
        cmd_repo_init
        ;;
      clone)
        cmd_repo_clone
        ;;
      push)
        cmd_repo_push
        ;;
      pull)
        cmd_repo_pull
        ;;
      status)
        cmd_repo_status
        ;;
      *)
        echo "Error: Unknown repo command: ${2:-}" >&2
        exit 1
        ;;
    esac
    ;;
  backup)
    check_timeshift
    if [ "${2:-}" = "list" ]; then
      sudo timeshift --list
    else
      sudo timeshift --create --comments "sys-sync backup (manual)"
    fi
    ;;
  restore)
    check_timeshift
    if [ $# -ge 2 ]; then
      sudo timeshift --restore --snapshot "$2"
    else
      sudo timeshift --restore
    fi
    ;;
  -d)
    check_timeshift
    if [ $# -lt 2 ]; then
      echo "Error: Please specify a snapshot to delete" >&2
      exit 1
    fi
    sudo timeshift --delete --snapshot "$2"
    ;;
  -c)
    check_timeshift
    if [ "${2:-}" = "backup" ]; then
      sudo timeshift --check
    else
      echo "Error: Unknown option for -c flag" >&2
      exit 1
    fi
    ;;
  "")
    echo "Error: No command provided" >&2
    print_help
    exit 1
    ;;
  *)
    # Default: pass to search
    eval "$CMD_SEARCH" "$@"
    ;;
esac
